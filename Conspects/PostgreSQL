[Соглашение по синтаксису SQL](https://www.sqlstyle.guide/ru/)
# Почему PostgreSQL?
* Бесплатный. Open Source.
* Легкая установка, даже без настройки.
* Хорошая транзакционность из коробки.
* Развитый диалект SQL.
* 90% диалекта PostgreSQL можно исопльзовать в других СУБД.

# Основные типы данных в PostgreSQL
__decimal/numeric__ - желательно исопльзовать для денег. так как другие типы могут накапливать ошибки.
__real/float4__ - исопльзуются в точных вычислениях.
<img src="./images/Postgre_data_types.png" alt="alt text" width="500"/>
__text__ - можно не указывать кол-во символов.
__bool__ - No, N, 0, Yes, Y, 1 - конвертируются в bool.
<img src="./images/postgresql_types_2.png" alt="alt text" width="500"/>
Это основные временные типы данных, есть еще дофига.
<img src="./images/postgresql_types_3.png" alt="alt text" width="500"/>
Так же есть:
* Arrays
* JSON
* XML
* Геометрические и другие типы
* custom - можно самому создавать типы данных
* NULL

# Создание БД
DROP DATABASE/TABLE [имя] - удалить базу данных/таблицу
CREATE DATABASE [имя] - создать базу данных
CREATE TABLE [имя] - создать таблицу
NOTNULL - Запрет пустого значения
PRIMARY KEY - Отмечает первичный ключ
CONSTRAINT - задание ограничений для таблицы, в данном случае создает имя для id

```SQL
CREATE TABLE publisher (
	publisher_id INTEGER NOT NULL,
	org_name VARCHAR(128) NOT NULL,
	adress TEXT NOT NULL,
	
	CONSTRAINT pk_publisher_id PRIMARY KEY (publisher_id)
);

CREATE TABLE book ( 
	book_id INTEGER NOT NULL,
	title TEXT NOT NULL,
	isbn VARCHAR(32) NOT NULL,
	
	CONSTRAINT pk_book_id PRIMARY KEY (book_id)
);
```

# Вставка данных в таблицу
INSERT - Вставить
INTO - куда?
VALUES - что?

Вариант 1.
```SQL
INSERT INTO book VALUES (1, 'The Diary of a Young Girl', '0199535566');
INSERT INTO book VALUES (2, 'Pride and Prejudice', '9780307594006');
INSERT INTO book VALUES (3, 'To Kill a Mockingbird', '032453242');
INSERT INTO book VALUES (4, 'The book of Gutsy Women', '2313428642');
INSERT INTO book VALUES (5, 'War and Peace', '169332468762');
```

Вариант 2.
```SQL
INSERT INTO book 
VALUES 
(1, 'The Diary of a Young Girl', '0199535566'),
(2, 'Pride and Prejudice', '9780307594006'),
(3, 'To Kill a Mockingbird', '032453242'),
(4, 'The book of Gutsy Women', '2313428642'),
(5, 'War and Peace', '169332468762');
```

Вариант 3.
```SQL
INSERT INTO public.book(
	book_id, title, isbn)
	VALUES (42, 'Valentines book', '19087521342341345345');
	
INSERT INTO public.publisher(
	publisher_id, org_name, adress)
	VALUES (922, 'Valentines', 'Puschino');
```

```SQL
INSERT INTO publisher
VALUES
(1, 'Everyman library', 'NY'),
(2, 'Oxford press', 'NY'),
(3, 'Grand publisher', 'Washington'),
(4, 'Simon', 'Chicago')
```

Для создание отношений используются foreign keys.
ALTER - для изменения
ADD - Добавить
REFERENCES - на что ссылается FOREIGN KEY
```SQL
ALTER TABLE book
ADD COLUMN publisher_id INTEGER;

ALTER TABLE book
ADD CONSTRAINT fk_publisher_id
FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id);
```

# Отношение один ко многим
Один издатель может издать много книг
У книги может быть один издатель
__Один__ издатель __ко многим__ книгам
```SQL
CREATE TABLE book(
	_id INTEGER NOT NULL,
	title TEXT NOT NULL,
	isbn VARCHAR(32) NOT NULL,
	publisher_id INTEGER NOT NULL,
	
	CONSTRAINT pk_book_id PRIMARY KEY(_id),
	CONSTRAINT fk_publisher_id FOREIGN KEY(publisher_id)
	REFERENCES publisher(publisher_id)
);
```
# Отношение один к одному
Очень похоже на отношение один ко многим, но foreign key должен бытьу униклаьным.
# Отношение многие ко многим
Данное отношение всегда моделируется с помощью введение 3-й таблицы.
таблица Книга.
таблица Автор.
таблица Автор_Книга. Где мы сопостовляем id книги и id автора. Но пары в этой таблице уникальны:
1 - 1
1 - 1 
такого не должно быть.
Для этого можно отдельно задать Primary key как пересечение двух таблиц:
CONSTRAINT table_table PRIMARY KEY (table1_id, table2_id)

# Учебная база данных от Microsoft
[Ссылка на репозиторий с этой базой](https://github.com/pthom/northwind_psql)
<img src="./images/Northwind_ER.png" alt="alt text" width="900"/>

# Простые запросы к базе
## Полная выборка
Из-за звездочки сильно теряется производительность. Так как одновременно нужно вывести дохуища данных.
SELECT * 
FROM name1, name2

## Выборка и элементарные арифметические операции
```SQL
SELECT order_id, shipped_date - order_date AS shiping_time 
FROM orders;
```

__+__ сложение
__-__ вычитание 
__*__ умножение
__/__ деление
__^__ степень
__|/__ квадратный корень

## DISTINCT - вывод уникальных строк.
Все лишние дубликаты не показываются.
```SQL
SELECT DISTINCT city
FROM employees;
```

## COUNT - подстчет результирующих строк
```SQL
SELECT COUNT(*)
FROM employees;

SELECT COUNT(DISTINCT country)
FROM employees;
```

## WHERE
SELECT *
FROM table
WHERE condition;

```SQL
SELECT column_name
FROM information_schema.columns
WHERE "table_name" = 'customers';

SELECT country, company_name, contact_name, phone
FROM customers
WHERE country = 'USA';

SELECT *
FROM products
WHERE unit_price > 20
ORDER BY unit_price;

SELECT COUNT(*)
FROM products
WHERE unit_price > 20;

SELECT *
FROM products
WHERE discontinued = 1;

SELECT *
FROM customers
WHERE city != 'Berlin'
ORDER BY city;

SELECT order_date
FROM orders
WHERE order_date >= '1945-01-01'
```

## AND OR
```SQL
SELECT DISTINCT order_id, contact_name, shipped_date - order_date as shippimg_time
FROM customers, orders
WHERE (shipped_date - order_date) < 10 AND contact_name LIKE 'B%'
ORDER BY contact_name;
```

## BETWEEN
нестрогое
[1; 100]
'>=1 and <=100'

## Вывод названия и тип данных столбцов.
```SQL
SELECT
    column_name,
    data_type
FROM
    information_schema.columns
WHERE
    table_name = 'products';
```

## IN, NOT IN
Вместо OR в данном случае лучше исопльзовать IN
```SQL
SELECT contact_name, country
FROM customers
WHERE 
country = 'Mexico' OR
country = 'Germany' OR
country = 'USA' OR
country = 'Canada';

SELECT contact_name, country
FROM customers
WHERE country IN (
'Mexico',
'Germany',
'USA',
'Canada'
)
```

## ORDER BY
упорядычивание по убывающей ASC
по возрастающей DESC

```SQL
SELECT contact_name, country
FROM customers
WHERE country NOT IN (
'Mexico',
'Germany',
'USA',
'Canada'
)
ORDER BY country ASC, contact_name ASC;
```

## MIN MAX AVG SUM
Выведет минимальное значение, максимальное или среднее арифметическое.
SUM - выведет сумму всех значений.
```SQL
SELECT MIN (order_date)
FROM orders 
WHERE ship_city = 'London';

SELECT MAX (order_date)
FROM orders 
WHERE ship_city = 'London';

SELECT AVG (unit_price)
FROM products
WHERE discontinued != 1;

SELECT SUM (unit_price)
FROM products;
```

## LIKE
% - заполнитель, placeholder 0,1 и более символов.
_ - 1 любой символ

LIKE 'U%' - строки, начинаются с U
LIKE '%a' - строки, заканчиваются на a
LIKE '%John%' - строки, содержащие John
LIKE '_oh_' - строки, где 2-й, 3-й символы oh, а первый и полсдений - любые

## LIMIT
Ограничение кол-во записей в результирующей таблице.
LIMIT 10 - 10 записей
Ставится в конце.

## IS NULL
```SQL
SELECT *
FROM table_name
WHERE item IS NULL или IS NOT NULL.
```

## GROUP BY
```SQL
SELECT ship_country, 
FROM orders
WHERE freight > 50
GROUP BY ship_country
ORDER BY ship_country DESC
```

## HAVING
это постфильтрация.
после фильтра WHERE может понадобится прописать еще один фильтр, поэтому нужно исопльзовать HAVING - это вторичный фильтр.
```SQL
SELECT category_id, SUM (unit_price * unit_in_stock)
FROM products
WHERE discontinued != 1
GROUP BY category_id
HAVING SUM (unit_price * unit_in_stock) > 5000
ORDER BY SUM (unit_price * unit_in_stock) DESC
```

## UNION INTERSECT EXCEPT
UNION ALL - если есть дубликаты, то они останутся, без ALL дубликатов не будет.
EXCEPT ALL - накладывает DISTINCT на левую часть выражения.
```SQL
SELECT country
FROM customers
UNION
SELECT country
FROM employees

SELECT country
FROM customers
INTERSECT 
SELECT country
FROM suppliers

SELECT country
FROM customers
EXCEPT
SELECT country
FROM suppliers
```

# Соединения
Левая таблица - то, что идет первым
Правая таблица - та, что идет второй.
## INNER JOIN
При данном соединении в итоговую выборку попадут только те строки левой таблицы, которые имеют соответствие (по внешнему ключу) в правой таблице.
<img src="./images/Inner_join.png" alt="alt text" width="2000"/>

## LEFT JOIN (left outer join)
При данном соединении из левой таблицы попадают абсолютно все записи и при этом, еслии есть соответствиее по внешнему ключу в правой таблице - то происходит обычное соденинение, но если этих соответствий нет, то в значениях там будут NULL
<img src="./images/left_join.png" alt="alt text" width="2000"/>

## RIGHT JOIN (right outer join)
Работает так же, как и LEFT JOIN, но наоборот. Попадают абсолютно все данные правйо таблицы. Если есть соответствие - то обычное соденинение, если нет - NULL значения.
<img src="./images/right_join.png" alt="alt text" width="2000"/>
Но этим соединением редко пользуются, так как достаточно LEFT JOIN, просто поменять местами таблицы при запросе, вот и все.

## FULL JOIN
По сути Left Join + Right Join. Забираем все записи из левой и правой. Если есть совпадения - то выводим. если нет сопоставлений - NULL.
<img src="./images/full_join.png" alt="alt text" width="2000"/>

## CROSS JOIN (декартово произведение)
Каждой записи в левой таблице сопоставляем все записи в правой таблице. Не учитывается внешний ключ. Просто берем левую таблицу и каждой записи сопоставляем каждую правую.
Если в левой таблице 2 строки, а вправой 10 строк и эти таблицы никакими ключами не связаны, то декартов произведение просто перемножит их и получится, что 2 строки левой таблицы выведутся по 10 раз каждая.
тупое перемножение.
<img src="./images/cross_join.png" alt="alt text" width="2000"/>

## SELF JOIN
