# Зависимости
В каждом коде со временем появляются зависимости, которые мешают расширению программы.
Например в классе __ChatPrinter__ есть зависимость от Класса __Reader__. Это отношение __композиция__.
Это плохо, так как при такой сильной зависимости сложно менять класс reader и его методы. Как только нужно будет изменить метод __print()__, сразу придется менять метод __chat()__. 
Это __Сильная зависимость__
```Java
public class ChatPrinter {
    // зависимость от Reader
   private Reader reader = new Reader();

    public void chat(String s){
        reader.print(s);
    }
}
```
Один из способов облегчения данной зависимости, это выделениее из класса __Reader__ интерфейс. Тогда будет легче работать с разными реализациями этого интерфейса. Но это не решает проблему прямой зависимости, это все еще композиция.
Это __Слабая зависимость__
```Java
public class ChatPrinter {
   private Reader helloReader = new HelloReader();
   private Reader byeReader = new ByeReader();

    public void chat(String s){
        helloReader.print(s);
        byeReader.print(s);
    }
}
```
Следующий шаг - это поменять __композицию__ на __агрегацию__, то есть принимать конкретную реализацию интерфейса __reader__ на вход в __конструкторе__ класса. И тогда нам будет очень просто редактировать функционал, можно просто создать другую реализацию интерфейса и передать ее на вход или поменять сам метод, клас __ChatPrinter__ теперь не зависит от конкретной реализации. Так же это называетс __инверсия зависимостей (Inversion of Control)__ - Классы должны зависеть от абстракций, а не от конкретной реализации.
Это __Отсутсвие зависимости__ так как ChatPrinter сам не создает объект Reader, он просто получает его на вход в конструкторе.
```Java
// ИНТЕРФЕЙС READER
public interface Reader {
    public void print(String s);
}

// КЛАСС ИСПОЛЬЗУЮЩИЙ ИНТЕРФЕЙС READER
public class ChatPrinter {
    Reader helloReader;
    Reader byeReader;

    // Теперь у нас есть возможность управлять функционалом интерфейса Reader
    // но класс ChatPrinter не знает о существовании и внутренней работе
    // данного интерфейса. это еще называется Агрегация
    public ChatPrinter(Reader helloReader, Reader byeReader) {
        this.helloReader = helloReader;
        this.byeReader = byeReader;
    }

    public void chat(String s){
        helloReader.print(s);
        byeReader.print(s);
    }
}

// ПРОГРАММА, ИСПОЛЬЗУЮЩАЯ ChatPrinter
public class Solution {
    public static void main(String[] args) {
        ChatPrinter chatPrinter = new ChatPrinter(new HelloReader(), new ByeReader());
        chatPrinter.chat("Valya");
    }
}
```
__Инверсия зависимостей (IoC)__ - это такой архитектурный подход, когда сущность не сама создает зависимости, а ей на вход поставляются зависимости. (Пример выше)

Но есть еще одна проблема. Как видно выше объект __ChatPrinter__ нужно еще __где-то создавать__. В данном случае в классе __Solution__. А это тоже __сильная зависимость__. И данная проблема решается с помощью __Внедрения зависимостей (Dependency Injection)__. А этим занимается __Spring__.

# Конфигурация Spring MVC
## XML
Для конфигурации с помощью XML нужен только 1 файл, например __applicationContext.xml__, внутри которого описываются все бины, а так же их properties и так далее.
Из важного здесь надо отметить:
__<context:property-placeholder location="classpath:application.properties"/>__ - Нужно, чтобы указать на местонахождениее файла .properties, в котором можно указывать разные данные и подставлять их, например __MessageMaker.defaultMessage__
__MessageMaker.defaultMessage=Valya__ <- внутри application.properties

```XML
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <context:property-placeholder location="classpath:application.properties"/>
    <bean id="byePrinter"
          class="MessageMaker.printer.ByePrinter"/>

    <bean id="helloPrinter"
          class="MessageMaker.printer.HelloPrinter"/>

    <bean id="messageMaker.byePrinter"
          class="MessageMaker.MessageMaker">
        <constructor-arg ref="byePrinter"/>
        <property name="defaultMessage" value="${MessageMaker.defaultMessage}"/>
    </bean>

    <bean id="messageMaker.helloPrinter"
          class="MessageMaker.MessageMaker"
          scope="prototype"
          factory-method="getMessageMaker">
        <constructor-arg ref="helloPrinter"/>
        <property name="defaultMessage" value="${MessageMaker.defaultMessage}"/>
    </bean>
</beans>
```
Далее для создания объектов и внедрения зависимостей используется такой синтаксис:
```Java
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
        "applicationContext.xml"
);

MessageMaker helloMessage = context.getBean("messageMaker.helloPrinter", MessageMaker.class);
helloMessage.print();

context.close();
```
В конце используем __context.close()__. Чтобы подчистить все бины, удалить фабрики и так далее.
## XML + Java Annotation
Это почти как XML конфигурация, но многое делается автоматически спрингом.
В данном случае опять понадобится файл конфигурации XML, но вместо создания бинов вручную, мы просто пишем аннотацию @Component
Для создания нескольких бинов, на основе одного класса в данном случае можно воспользоваться наследствием, подробнее:
https://www.baeldung.com/spring-same-class-multiple-beans

Добавили Компонент скан и проперти плейсхолдер.
```XML
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <context:property-placeholder location="classpath:application.properties"/>
    <context:component-scan base-package="shilaev"/>
</beans>
```
@Value - Для подставления значений из файла __.properties__ или просто значений
@Autowired - для авто-инъекции зависимостей
@Qualifired - для выбора какой именно класс внедрить
```Java
    @Value("${MessageMaker.gefaultMessage}")
    public void setDefaultMessage(String defaultMessage) {
        this.defaultMessage = defaultMessage;
    }

    @Autowired
    public MessageMakerByePrinter(@Qualifier("byePrinter") Printer printer) {
        super(printer);
    }
    
```
С контекстом все то же самое.
```Java
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext.xml"
        );

        MessageMaker helloMessage = context.getBean("messageMaker.helloPrinter", MessageMaker.class);
        helloMessage.print();

        MessageMaker byeMessage = context.getBean("messageMaker.byePrinter", MessageMaker.class);
        byeMessage.print();

        context.close();
```

## Java Annotation