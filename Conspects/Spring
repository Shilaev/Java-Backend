## Spring - это и библиотека, и фреймворк. То есть он предоставляет каркас приложения, вдогонку к готовым методам.
Состоит из множества компонентов, что облегчает разработку на Java:
* Application COntext
* Dependency Injection
* Аналог JDBC
* Spring MVC - Компонент разработки WEB приложений
* Spring Security
* Spring Boot
* Spring WebFlow
* и дохрена других компонентов.

## Application Context, Dependency Injection.
Типичное Java приложение - это набор Java объектов, которые взаимодействуют и ссылаются на друг друга.
И вот эти ссылки друг на друга - называются Зависимости.
<img src="./images/Java_App_Dependency.png" alt="alt text" width="400"/>

Когда Java приложение запускается, все Java объекты создаются и помещаются в оперативную память. В ходе работы приложения, объекты могут добавляться\удаляться. Могут изменяться связи между объектами. Большое кол-во объектов и связей между ними встречается в любом более менее сложном Java приложении. Spring помогает в работе с множеством объектов.

Можно, конечно и без Spring обойтись, но это сложно и громостко. Так как придется очень много зависимостей обрабатывать. Код станет запутанным. Не прослеживается иерархия между объектами. У подклассов тоже могут быть зависимостей много. Куча лишнего кода.

Если исопльзовать Spring, то мы просто описываем необходимые нам объекты. А дальше Spring сам создает эти объекты и берет на себя управление этими объектами (их жизненный цикл и так далее)

<img src="./images/Spring_Application_Context_Dependency_Injection_example.png" alt="alt text" width="900"/>

Так же Spring сам внедряет нужные зависимости. Нам нужно тулько описать связь, дальше Spring все сделает за нас.
<img src="./images/Spring_Dependency_Injection_example.png" alt="alt text" width="900"/>

## Spring Intellij Idea настройка
Лучше всего создать через создание проекта Maven. Затем на сайте [Maven repository](https://mvnrepository.com/) найти Нужные зависимости и указать их в Maven.pom
<img src="./images/maven_pom_example_dependency.png" alt="alt text" width="900"/>

# Инверсия управления
Проблема в том, что в коде очень часто появляются зависимости.
<img src="./images/inversion_of_control.png" alt="alt text" width="900"/>
<img src="./images/inversion_of_control2.png" alt="alt text" width="900"/>

```Java
interface Music {
}

class Deathcore implements Music {
}

class Mathhcore implements Music {
}

/*
public class MyMusicPlayer {
    private Music music;

    public void playDeathcore() {
        music = new Deathcore();
    }

    public void playMathcore() {
        music = new Mathhcore();
    }
}
 */

public class MyMusicPlayer {
    Music music;

    public MyMusicPlayer(Music music) {
        this.music = music;
    }

    public void playMusic(){
        System.out.println(music.toString());
    }
}
```

## Bean
Это просто Java объект. Когда Java объекты создаются с помощью Spring, они называются бинами. Бины создаются из Java классов (так же, как и обычные объекты)
```XML
<bean id="testBean"
      class = "ru.shilaev.TestBean">
      <constructor-arg value="Neil"/>
</bean>
```

Спринг файлы можно конфигурировать через:
1) XML
2) Java аннотации и XML
3) Java код

## Типичные шаги при разработке с помощью Spring
- Создать Java классы - будущие бины
- Создать бины и связать их с помощью спринга
- При использовании все бины брать из контейнера Spring

## Способы внедрения зависимостей
- через конструктор
- через setter
- scope, factory method и т.д
- xml, аннотации, java-code
- autowiring - авоматизированная система внедрения зависимостей

## Внедрение зависимости через XML
Используем конструктор
```XML
<bean id="musicBean" class="shilaev.MusicPlayerExample.Rap"/>

<bean id="musicPlayerBean" class="shilaev.MusicPlayerExample.MusicPlayer">
   <constructor-arg ref="musicBean"/>
</bean>
```

Используем setter
```XML
<bean id="musicPlayerBean" class="shilaev.MusicPlayerExample.MusicPlayer">
    <property name="music" ref="musicBean"/>
</bean>
```

используем файл .properties
внутри файла все выглядит так
musicPlayer.volume=50
```XML
<context:property-placeholder location="musicPlayer.properties"/>
<bean id="musicPlayerBean" class="shilaev.MusicPlayerExample.MusicPlayer">
    <constructor-arg ref="musicBean"/>
    <property name="volume" value="${musicPlayer.volume}"/>
</bean>
```
Несколько значений сразу
```XML
<bean id="musicPlayerBean" class="shilaev.MusicPlayerExample.MusicPlayer">
    <property name="volume" value="${musicPlayer.volume}"/>
    <property name="musicList">
        <list>
            <ref bean="deathcoreMusicBean"/>
            <ref bean="rapMusicBean"/>
            <ref bean="neoClassicalMusicBean"/>
        </list>
    </property>
</bean>
```

## Область видимости бинов - Scope
Scope - задает то, как Spring будет создавать бины.
По умолчанию используется Singletone scope. То есть при создании объекта создается только один объект. Ссылка на который потом используется единая и везде.
Scope prototype - исопльзуется, когда у бин с изменяемыми состояниями.

## Жизненный цикл бина
<img src="./images/BeanLifeCycle.png" alt="alt text" width="900"/>

__init-method__ - запускается в ходе инициализации бина.
Инициализация ресурсов, обращений к внешним файлам, запуск БД.

__destroy-method__ - запускается в ходе уничтожения бина (при завершении приложения)
Очищение ресурсов, закрытие потоков ввода-вывода, закрытие доступа к БД.

```XML
<bean id="deathcoreMusicBean" class="shilaev.MusicPlayerExample.Deathcore"
    init-method="doMyInit"
    destroy-method="doMyDestroy"
/>
```
Методы создаются в классе Deathcore в данном случае.

__Тонкости Init, Destroy методов__
- __Модификатор доступа__. У этих методов может быть любой модификатор
- __Возвращаемое значение__. Может быть любое, но чаще void, так как нет возможности получить возвращаемое значение.
- __Название__. Любое.
- __Аргументы__. Не принимают на вход аргументы.
- __Prototype__. Для бинов с Prototype scope медот destroy не вызывается.

__factory-method__ - фабричный метод, паттерн программирования. Предлагает делегировать создание объектов особому фабричному методу.

```XML
<bean id="deathcoreMusicBean" class="shilaev.MusicPlayerExample.Deathcore"
    init-method="doMyInit"
    destroy-method="doMyDestroy"
    factory-method="getClassicalMusic"
/>
```

В данном случае по умолчанию стоит scope singleton, то ссылка будет на один и тот же объект.

## Аннотации
Создание с помощью аннотаций, вместо XML
Spring сканирует все классы и находит те, что с аннотациями. Автоматически создает бины из этих классов.
```Java
@Component
public class Music {
    //
}
```

__@Component__ - помечаем класс, если хотим, чтобы содался бин из этого класса
Можно указать id для создаваемого бина, можно не указывать. Если не укажем, то автоматический id будет начинаться с маленькой буквы.

Для того, чтобы включить сканирование, в конфигурационном файле ресурсов Спринга нужно указать эту строчку
```XML
<context:component-scan base-package="shilaev.musicPlayerExampleAnnotation"/>
```

__@Autowired__ - Автоматическая система внедрения зависимостей.
- Сканирует все классы с аннотацие @Component, создает бины этих классов.
- Сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве зависимости
- Если находится один подходящий бин, он внедряется в качестве зависимости
- Если не находится ни одного - ошибка
- Если несколько находится - неоднозначеность.

Аннотация внедряет зависимости даже в приватное поле, с помощью рефлексии.

__@Qualifier("name")__ - Определяет какой тип нужно внедрить

__@Scope__ -  Выбирает тип создаваемого бина. Singleton или Prototype

__@Value__ - Нужно для внедрение значений полей. 
1) Создаем файл .properties
2) Прописываем <context:property-placeholder location="[PATH_TO].properties"/>
3) 
```Java
@Value("${propertiesFileName.field}")
private String name;
```

__@PostConstuct__ - инит метод

__@PreDestroy__ - дестрой метод

## Конфигурация Spring через Java code
До этого рассматривалась конфигурация через XML файл, теперь можно из кода


# Spting MVC
Model-view-controller - архитектура разработки.
Model - логика работы с данными
View - логика предствления, интерфейс
Controller - логика навигации, обработка запросов.

Spring MVC приложение это обычные классы Java. Часто исопльзуется аннотация @Controller - для пометки контроллера - логики представления.
DispatcherServlet - Это точка вхождения в приложение Spring MVC. За нас его уже сделали ребята из SPring.

HTTP запрос от пользователя:
1) Приходит на сервер. Сервер обрабатывает запрос и передает его на Spring MVC приложение.
2) Запрос попадает в DispatcherServlet.
3) DispatcherServlet отправляет запрос на правильный контроллер.

## Controller
Выглядит как Java класс с аннотациями спринг
1) Обрабатывает запросы пользователя.
2) Обменивается данными с моеделью.
3) Показывает пользователю правильное представление.
4) Переадресовывет пользователя на другие страницы.

## Model
Выглядит как Java класс с аннотациями спринг
1) Хранит в себе данные.
2) Взаимодействует с БД для получения данных.
3) Отдает данные контроллеру.

## View
Выглядит как HTML код с шаблонизаторами.
1) Получает данные от контроллера и отображает их в браузере
2) Для динамического отображения данных ислпользуется шаблонизаторы (Thymeleaf, Freemarker, Velocity)
Шаблонизаторы помогают автоматически генерировать HTML страницы.

## Первое MVC приложение
Для начала без архитектуры MVC.

Для удобной работы можно  подключить сервер Apache Tomcat. Сервер это то, куда мы будем обращаться из браузера. Для этого нужно просто его скачать и следовать инструкции на сайте.
В настройках конфигурации добавить Tomcat servel - local
