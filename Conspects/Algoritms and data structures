# Грокаем Алгоритмы

# Знакомство с алгоритмами
Алгоритм - набор инструкций для выполнения некоторой задачи.
<br>

## Бинарный поиск
На входе алгоритм получает отсортированный список элементов. И возвращает позицию искомого элемента, если он есть в списке элементов, в противном случае вернет null.
<img src="./images/binary_search.png" alt="alt text" width="500"/>
Шаг 1: 55? Много. - Сразу же отметается огромный массив чисел от 55 до 82.
Шаг 2: 34? Мало. - Отметаем все числа от 6 до 34
шаг 3: 44? Да

Сколько шагов понадобится, если я ищу слово в словаре из 240 000 элементов? В худшем случае. (загаданное число первое или последнее в списке)
Простой перебор: 240 000, просто буду прибавлять 1, пока не дойду до конца списка
Бинарный поиск: 2^18 - 18 шагов. То есть log2(240 000) = 17,8 = 18.
То есть __сложность бинарного поиска:__ O(log2(N) = O(log N), так как log без основания, в случае с алгоритмами, всегда означает log2

__Время выполнения__
Если список состоит из 100 элементов, то поиск займет 7 попыток, 
если список состоит из 4 миллиардов, то поиск займет 32 попытки.
То есть имеем логарифмическое время выполнения.
В случае с просытм перебором имеем линейное время, так как 100 элементов - 100 попыток и т.д.
<br>

## O-Большое
Это специальная нотация, которая описывает скорость алгоритма. Это нужно для удобство выбора алгоритма, оценки его скорости выполнения, так как время выполнение каждого алгоритма растет с разной скоростью.
O-большое показывает с какой скоростью растет время выполнение алгоритма с ростом входных данных.
О-большое не сообщает скорость в секундах, а позволяет сравнить количество операций.
О-большое определяет время выполнения алгоритма в худшем случае.

__Самые популярные разновидности О-большое__
* __O(log n)__ - логарифмическое время: бинарный поиск
* __O(n)__ - Линейное время: простой поиск
* __O(n * log n)__ - эффективные алгоритмы сортировки: быстрая сортировка
* __O(n^2)__ - медленные алгоритмы сортировки: сортировка выбором
* __O(n!)__ - очень медленные алгоритмы: задача коммивояжера.
<img src="./images/algorytm_graphics.png" alt="alt text" width="700"/>

## Итоги
* Скорость алгоритмов измеряется не в секундах, а в темпе роста колличества операций. Насколько быстро растет кол-во операций, с увелиением кол-ва данных.
* Время выполнения O(log n) быстрее O(n), а с увеличением размера списка, в котором ищется значение. оно становится __намного__ быстрее.

# Список и Массив
Чтение   O(n) O(1)
Вставка  O(1) O(n)
Удаление O(1) O(n)

__Массивы__
Массив хранится в памяти последовательно, ячейки расположены друг с другом, если нужно добавить новый элемент, а ячейка рядюом занята, то придется создавать новый массив с вместительностью + 1 в другом месте памяти.
Так как массив хранится последовательно, мы всегда можем очень быстро прочитать любое значение в массиве, так как знаем где конкретно н аходится каждый элемент.
При удалении элемента (в худшем случае в середние) придется сдвигать все элементы, а это опять создание нового массива.
Когда использовать? Когда мало вставок и удалений, но много чтения.
<img src="./images/array_visualization.png" alt="alt text" width="300"/>
<br>

__Списки__
Списки хранятся в памяти в любой доступной ячеке, так как каждый предыдущий элемент знает о последующем элементе списка. 1 знает адрес 2, 2 знает адрес 3, 3 знает адрес 4 и так далее.
Из-за этого выделение памяти на новй элемент списка происходит с постоянной скоростью. Просто в элемент добавляется ссылка на новый элемент. Даже если добавление в середину, просто меняются 2 ссылки предыдущего и следующего элемента.
Удаление так же происходит очень быстро - меняются ссылки, либо вовсе удаляются.
А вот чтение имеет линейную скорость, так как в худшем случае, если нам нужен объект в середине, и даже если у нас двусвязный список м будем последовательно, снача 1 элемент, потом 2, читать их, пока не дойдем до нужного.
Но если программа подразумевает ПОСЛЕДОВАТЕЛЬНОЕ чтение, то в этом нет проблемы.
<img src="./images/list_visualization.png" alt="alt text" width="300"/>
<br>

Из этих простейших структур, можно составлять составные, например массив списков.
В данном случае поиск медленнее, чем для массивов и быстрее, чем для связных списков.
Вставка - быстрее. чем для массивов, с такой же скоростью, для связных списков.
<img src="./images/array_of_lists.png" alt="alt text" width="400"/>
<br>

# Сортировка выбором