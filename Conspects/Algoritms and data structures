# Грокаем Алгоритмы

# Знакомство с алгоритмами
Алгоритм - набор инструкций для выполнения некоторой задачи.
<br>

## Бинарный поиск
На входе алгоритм получает отсортированный список элементов. И возвращает позицию искомого элемента, если он есть в списке элементов, в противном случае вернет null.
<img src="./images/binary_search.png" alt="alt text" width="500"/>
Шаг 1: 55? Много. - Сразу же отметается огромный массив чисел от 55 до 82.
Шаг 2: 34? Мало. - Отметаем все числа от 6 до 34
шаг 3: 44? Да

Сколько шагов понадобится, если я ищу слово в словаре из 240 000 элементов? В худшем случае. (загаданное число первое или последнее в списке)
Простой перебор: 240 000, просто буду прибавлять 1, пока не дойду до конца списка
Бинарный поиск: 2^18 - 18 шагов. То есть log2(240 000) = 17,8 = 18.
То есть __сложность бинарного поиска:__ O(log2(N) = O(log N), так как log без основания, в случае с алгоритмами, всегда означает log2

__Время выполнения__
Если список состоит из 100 элементов, то поиск займет 7 попыток, 
если список состоит из 4 миллиардов, то поиск займет 32 попытки.
То есть имеем логарифмическое время выполнения.
В случае с просытм перебором имеем линейное время, так как 100 элементов - 100 попыток и т.д.
<br>

## O-Большое
Это специальная нотация, которая описывает скорость алгоритма. Это нужно для удобство выбора алгоритма, оценки его скорости выполнения, так как время выполнение каждого алгоритма растет с разной скоростью.
O-большое показывает с какой скоростью растет время выполнение алгоритма с ростом входных данных.
О-большое не сообщает скорость в секундах, а позволяет сравнить количество операций.
О-большое определяет время выполнения алгоритма в худшем случае.

__Самые популярные разновидности О-большое__
* __O(log n)__ - логарифмическое время: бинарный поиск
* __O(n)__ - Линейное время: простой поиск
* __O(n * log n)__ - эффективные алгоритмы сортировки: быстрая сортировка
* __O(n^2)__ - медленные алгоритмы сортировки: сортировка выбором
* __O(n!)__ - очень медленные алгоритмы: задача коммивояжера.
<img src="./images/algorytm_graphics.png" alt="alt text" width="700"/>

## Итоги
* Скорость алгоритмов измеряется не в секундах, а в темпе роста колличества операций. Насколько быстро растет кол-во операций, с увелиением кол-ва данных.
* Время выполнения O(log n) быстрее O(n), а с увеличением размера списка, в котором ищется значение. оно становится __намного__ быстрее.

# Сортировка выбором