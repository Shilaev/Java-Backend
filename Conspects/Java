# Примитивные типы
<img src="./images/JavaPrimitiveTypes.png" alt="alt text" width="900"/>

# Описание структуры проекта Intelije
<img src="./images/ideaFolder.png" alt="alt text" width="200"/>

Это кастомизация самого IDE в виде конфигураций, настроек, промежуточные состояния. Все это сохранятеся здесь. 
Этот каталог не нужен, его можно добавлять в .gitignore

.iml - так же файл, в котором информация, которая нужна только для меня, можно не обавлять в гит.

[Рекомендации по организации файлов в проекте Maven](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)

<img src="./images/mavenLayout.png" alt="alt text" width="900"/>

super - разрешен для записи, но не предоставляет инфу
extends - разрешен для предоставления инфы, но запрещен для записи
Пример - получаем список для записи и записываем в него другйо список.
```Java
public static <T> void copy (List<? super T> dest, List<? extends T> src){} 
```

## Generics
__Основа__
Обобщения позволяют уйти от жесткого определения используемых типов.
T - заглушка для типа. называется Универсальным параметром, вместо него можно подставить любой тип.
При создании объекта указывается какйо тип будет исопльзоваться вместо T.
```Java
class Account<T> {
    private T id;
    private int sum;

    public Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}

public class Generics {
    public static void main(String[] args) {
        Account tomAcc = new Account<Integer>(1, 100000);
        System.out.println(tomAcc.getId());
        System.out.println(tomAcc.getSum());

        Account mariAcc = new Account<String>("second", 10000);
        System.out.println(mariAcc.getId());
        System.out.println(mariAcc.getSum());
    }
}
```

__Обобщенные интерфейсы__
```Java
Можно сразу указывать тип, которым будет заменяться T, либо делать класс <T>.
interface PersonalAccount<T> {
    T getId();

    T getSum();

    void setSum(T newSum);
}

class MyPersonalAccount implements PersonalAccount<Integer> {

    int id;
    int sum;

    public MyPersonalAccount(int id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    @Override
    public Integer getId() {
        return id;
    }

    @Override
    public Integer getSum() {
        return sum;
    }

    @Override
    public void setSum(Integer newSum) {
        sum = newSum;
    }
}

public class Example2 {
    public static void main(String[] args) {
        MyPersonalAccount myPersonalAccount = new MyPersonalAccount(1, 123);
        System.out.println(myPersonalAccount.getId());
        myPersonalAccount.setSum(123);
        System.out.println(myPersonalAccount.getSum());
    }
}
```

__Обобщенные методы__
```Java
class Printer {
    public static <T> void print(T[] items) {
        for (T item : items) System.out.println(item);
    }
}

public class Example3 {
    public static void main(String[] args) {
        Printer.print(
                new String[]{
                        "123123",
                        "1425354",
                        "lkdfjqwef",
                        "ajd;flaksjdf"
                }
        );
    }
}
```

__Обобщенные конструкторы__
```Java
class Account{
     
    private String id;
    private int sum;
     
    <T>Account(T id, int sum){
        this.id = id.toString();
        this.sum = sum;
    }
     
    public String getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}
```

__Ограничение обобщений__
Для установки ограничения тавится слово __extends__
В данном случае в классе __Transaction__ можно заменить __T__ на класс __Account__, либо на любого его наследника.
```Java
class Account{}
class Transaction<T extends Account>{}
```
```Java
class BaseAccount {
    private int id;
    private int sum;

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }

    public int getId() {
        return id;
    }

    public BaseAccount(int id, int sum) {
        this.id = id;
        this.sum = sum;
    }
}

class ClassicAccount extends BaseAccount {

    public ClassicAccount(int id, int sum) {
        super(id, sum);
    }
}

class Transaction<T extends BaseAccount> {
    private T from;
    private T to;
    private int sum;

    public Transaction(T from, T to, int sum) {
        this.from = from;
        this.to = to;
        this.sum = sum;
    }

    public void execute() {
        int newSum = from.getSum() - sum;
        from.setSum(newSum);

        newSum = to.getSum() + sum;
        to.setSum(newSum);
    }
}

public class Example4 {
    public static void main(String[] args) {
        ClassicAccount bob = new ClassicAccount(1, 10000);
        ClassicAccount mari = new ClassicAccount(2, 0);
        System.out.println(bob.getSum());
        System.out.println(mari.getSum());

        Transaction sendMoney = new Transaction<>(bob, mari, 10000);
        sendMoney.execute();
        System.out.println(bob.getSum());
        System.out.println(mari.getSum());
    }
}
```

## Java Collections Framework
Набор связных классов и интерфейсов, реализующих commonly reusable collections структур данных.
То есть это набор классов и интерфейсов, в которых реализовано хранение объектов.
Есть небольшая конвенция по испльзованию. Советуется при создании любого "массива" ссылаться на интерфейс, который этот класс "массив" реализует.
```Java
List<Integer> arrayList = new ArrayList<>();
```
Это нужно, если вдруг нам понадобится много удалять, то лучше исопльзовать LinkedList, тогда можно сделать так
```Java
List<Integer list = new ArrayList<>();
list = new LinkedList<>(list);
```
Это не очень полезно, но можно

__Структура интерфейсов и классов Collections__
<img src="./images/collections.png" alt="alt text" width="900"/>

__List__
__ArrayList__ - позволяет добавлять столько данных, сколько есть памяти на ЭВМ.
Все объекты класса ArrayList использует внутренний массив. Когда кол-во элементов становитс ябольше, просто создаетс яновый массив и объекты старого копируются в новый, а новый в 2 раз больше.
По этой причине метод Remove малоэффективен, если удаление идет в середине массива или в начале.
[1,2,3,4,5] <- Если удалять 5, то он просто удаляет 5 и сокращает размер массива, но если удалить 3, то сначала удаляется 3, затем все элементы после 3 переносятся на 1 шаг влево, затем сокращается размер массива.
Для решения этой проблемы есть __LinkedList__.

Использовать когда: 
1) Много добавлений в конец листа
2) Много считываний (get) по индексу

__LinkedList__
Двусвязный список
Реализует интерфейс List, но иначе, чем Array.
head -> [0] -> [1] -> [2]
Если мы добавим элемент в начало листа либо, то просто в head укажется ссылка на новый элемент, а в новом элементе на элемент [0]
head <-> [new] <-> [0] <-> [1] <-> [2]
Так же если удалять элемент, то мы просто меняем ссылки.
но если нужно поулчить элемент по индексу, то это будет очень медленно, так как нужно будет прйоти по всей цепочке элементов.
Так же, если добавлять элемент в конец листа, придется дойти до последнего элемента и присвоить ему ссылку на следующий элемент, для этих задач лучше __ArrayList__
LinkedList лучше всего использовать, если много приходится удалять.

Исопльзовать когда:
1) Много удалений
2) Много добавлений в начало

__Map__
Map - от слова отображение. Отображение множеств - это правило, которое каждому элементу множества A ставит в соответствие один и только один элемент множества B.

__HashMap__
```Java
Map<Integer, Integer> map = new HashMap<>();
```
Если убрать <> в new HashMap(); то внутри будут объекты класса Object, а не HashMap.
В java key и value не рассматриваются отдельно, вместе они составляют __Map.Entry<K, V>__
В HashMap элемены не имеют никакого порядка, он это не гарантирует. Можно задать объекты в одном порядке
1 - один
2 - два, но со следующим запуском было 2 - два, 1 - один.
Это происходит из-за того, что исопльзуется хэширование, оно зависит от случайных величин.
То есть HashMap нужно использовать тогда, когда не важен порядок внутри Map.
__LinkedHashMap__
Сохраняет порядок добавления пар.
__TreeMap__
Сортирует пары ключ значение по ключу.

__Set__
set - множество. Коллекция, которая хранит в себе уникальные элементы.
__HashSet__
Обычное множество уникальных элементов, не гарантирует порядок.
__LinkedHashSet__
Множество уникальных элементов, гарантирует порядок.
__TreeSet__ 
Множество уникальных элементов, сортирует.

__Методы hashcode, equals__
В данном случае Из-за того, что класс Person не содержит методов hashCode() и Equals() - они не могут быть сравнены мжеду собой и поэтому для компа это одинаковые объекты. 
А любой объект класса Object (и его наследники) - содержит эти методы, поэтому 2 одинаковых значения не пройдут.
За счет этих методов комп понимает, что это разные объекты.
```Java
     Set<Person> personSet = new HashSet<>();

        personSet.add(new Person(1, "Mike"));
        personSet.add(new Person(1, "Mike"));

        System.out.println(personSet);
        //[Person{id=1, name='Mike'}, Person{id=1, name='Mike'}]


        Set<String> stringSet = new HashSet<>();

        stringSet.add("MyString");
        stringSet.add("MyString");

        System.out.println(stringSet);
        //[MyString]


class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
```
После автоматической генерации этих методов, объекты можно будет сравнивать между собой по хэш коду и с помощью метода equals.
__Контракт HashCode и Equals__
Почему нужно 2 метода для сравнения?
Потому что используя эти 2 методы мы сравниваем объекты наиболее быстрым образом. И при этом иногда метод hashCode выдает неправильные результаты, поэтому 2-й метод нужен еще и для допроверки.

Хэширование - преобразование массива входных данных __произвольной длины в__ выходную битовую __строку фиксированной длины__, выполняемое поределенным алгоритмом. Функция называется - хэш-функция.

Колличество хэш-ключей ограничино, так как всегда ограниченное кол-во комбинаций, которые сгенерируются хэш-функцией. А кол-во комбинаций объектов - бесконечное множество.

Алгоритм проверки 
1. Вызываем hashCode() у двух объектов и сравниваем, если они не равны, то объекты 100% разные, если равны, то
2. вызываем метод Equals и проверям уже поля объектов, чтобы допроверить одинаковость объектов.


__HashMap__
Как работает данная коллекция.
Хэширование в этом классе позволяет ускорить работу коллекции.

Реализация класса hashMap
<img src="./images/hashMap_class.png" alt="alt text" width="400"/>
Когда мы хотим положить объект внутрь отображения, то сначала генерируется хэш код, но он может быть очень большим, поэтому в данном случае сначала хэш код побитово умножаем на n-1, что дает гарантию, что после этого умножения число будет между 0 и 15, так как n = 16.
<img src="./images/hashMap_class2.png" alt="alt text" width="400"/>
Если вдруг после расчетов индекс совпал, то мы просто добавляем этот элемент в конец связного списка (это очень быстро, просто добавляем ссылку на новый элемент)
<img src="./images/hashMap_class3.png" alt="alt text" width="400"/>
Получение объекта тоже делается через расчет индекса. В этомпреимущество, мы не пробегаем по массиву, а просто расчитываем ячейку внутреннего массива и берем от туда элемент.
<img src="./images/hashMap_class4.png" alt="alt text" width="400"/>

## Коллекции

    ArrayList: простой список объектов

    LinkedList: представляет связанный список

    ArrayDeque: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце

    HashSet: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код

    TreeSet: набор отсортированных объектов в виде дерева

    LinkedHashSet: связанное хеш-множество

    PriorityQueue: очередь приоритетов

    HashMap: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение

    TreeMap: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение

__класс ArrayList и интерфейс List__
Простой список элементов.
Часто используемые методы
    void add(int index, E obj): добавляет в список по индексу index объект obj

    boolean addAll(int index, Collection<? extends E> col): добавляет в список по индексу index все элементы коллекции col. Если в результате добавления список был изменен, то возвращается true, иначе возвращается false

    E get(int index): возвращает объект из списка по индексу index

    int indexOf(Object obj): возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается -1

    int lastIndexOf(Object obj): возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается -1

    ListIterator<E> listIterator (): возвращает объект ListIterator для обхода элементов списка

    static <E> List<E> of(элементы): создает из набора элементов объект List

    E remove(int index): удаляет объект из списка по индексу index, возвращая при этом удаленный объект

    E set(int index, E obj): присваивает значение объекта obj элементу, который находится по индексу index

    void sort(Comparator<? super E> comp): сортирует список с помощью компаратора comp

    List<E> subList(int start, int end): получает набор элементов, которые находятся в списке между индексами start и end

__Очереди и класс ArrayDeque и интерфейс Queue__
Принцип работы - первый вошел, первый вышел.
Интерфейс Deque расширяет интерфейс Queue.


## Многопоточность Java
__Процесс и поток (Thread)_ - Это совокупность кода и данных, разделяющих общее виртуальное адрессное пространство.

При помощи процессов выполнение разных программ изолированно друг от друга: каждое приложение использует свою область памяти, не мешая другим программам.

<img src="./images/thread.png" alt="alt text" width="900"/>

Под процесс выделяется стековая память при запуске, по мере работы процесса он потребляет память из кучи.
Процесс не может влезть в память другого процесса их память изолирвоанна. 
За изолированность отвечает операционная система.
При запуске прцоесса запускается основной поток данного процесса Main thread. 
Когда мы входим в main - точка входа в программу - запускается основной поток. Процесс не может работать без основного потока.
В рамках одного процесса может быть запущено много потоков, которые как раз и помогают распаралеливать задачи.

Потоки - если у нас 4 ядра процессора и 4 потока, то они реально физически работуют параллельно, но если у нас 30 потоков, то 4 ядра не могут распараллелить их, поэтому появляется термин Псевдопараллельность.
Операционная система (sheduler модуль) поочередно дает управление каждому потоку.

В большинстве случаев имеет место всевдопараллельность.

Как создать поток и запустить его.
1. Нужно переопределить класс Thread
2. Затем где это нужно запустить его thread.start();
Другой вариант:
1. Использовать интерфейс Runnable
2. и через функцию run() запустить его.

С помощью Sleep можно заморозить процесс на некоторое время
<img src="./images/sleep.png" alt="alt text" width="900"/>
С помощью join можно подождать завершение другого потока.
<img src="./images/join.png" alt="alt text" width="900"/>

__Монитор__ - для целей синхронизации между потоками Java использует некий механизм, который назвается монитор.
С каждым объектом ассоциирован некоторый монитор, а потоки могут его заблогировать "lock" или разблокировать "unlock"
<img src="./images/monitor.png" alt="alt text" width="900"/>
<img src="./images/mark_words.png" alt="alt text" width="500"/>

__Жизненный цикл потоков__
<img src="./images/thread_lifecycle.png" alt="alt text" width="900"/>

__Многопоточность из Философия java__
__Общее описание__
Параллельность часто повышает производительность программ, выполняющихся на _одном_ процесоре. Так как:
__Block__ - Ситуация, при которой одна задача в программе не может продолжать выполнение из-за каких-то условий, неподконтрольных программе (обычно ввод-вывод), эта задача или программный поток _блокируется_. Однако, если программа написано с учетом параллельности, то во время блока одной задачи другие могут продолжать выполняться, программа не будет простаивать.

С точки зрения производительности на однопроцессорной машине имеет смысл делать параллельность, если некоторые задачи могут блокироваться.

Один из простейших механизмов реализации параллельности - _процессы_ уровня операционной системы.
__Процесс__ - представляет собой самостоятельную программу, выполняемую в собственном адрессном пространстве. Многозадачная операционная система может одновременно выполнять боле еодного процесса, переключая процессор между процессами (сначала одному процессу уделит вермя. потом другому, в итоге все процессы двигаются равномерно и можно скзаать "параллельно" друг другу)

Система обычно изолирует процессы друг от друга, чтобы они не мешались. Но параллельные системы, совместно используют ресурсы - память, ввод и вывод, поэтому основные трудности при написании многопоточных программ связаны с координацией использования ресурсов между задачами разных потоков, чтобы в любой момент времени ресурс был доступен только для одной задачи.

Пример:
Сохранение одного файла в разные места. 
Однопоточный ввариант - файл последовательно сохраняется на каждый носитель, сохранение на последующий носитель не возможно, пока текущий в работе.
Многопоточный вариант - все процессы примерно одновременно действуют, а значит сохранение значительно ускоряется.

В Java используется потоковая модель с _вытеснением_, при которой механизм планирования выделяет временные _кванты_ каждому потоку, переодически прерывая его выполнение и осуществляя переключение  контекста на другой поток так, чтобы кжадому потоку выделялось разумное время на выполнение его задачи.
в _кооперативной многопоточной системе_ каждая задача добровольно уступает управление, для чего программист должен сознательно вставить в кжадую задачу соотвествующую команду.

Кооперативная система имеет 2 преимущества над _вытеснительной_:
1. Переключение контекстаобычно требует существенно меньше затрат
2. Количество одновременно выполняемых независимых задач теоретически не ограничивается
Но некоторые кооперативные системы не предусматривают распределение задач между процессорами и это сущесвтенное ограничение.

__Основы построения многопоточных программ__
Параллельное программирование позволяет делить программу на несколько независимых частей (в несколько отдельных, самостоятельно выполняющихся подзадач). Каждая такая задача называется __Thread - поток__
__Поток__ - это выполняемая параллельно в рамках процесса последовательность команд программы.
Процессор вмешивается в происходящее и выделяет каждому потоку некоторый отрезок времении (квант).
Каждый поток полагает, что он исопльзует процессор монопольно, но на деле время процессора распределяется между ними всеми.
(Кроме случаев, если эвм содержит несколько процессоров, тогда 1 поток на 1 процессор)

__Java синтаксис и практика__