# Примитивные типы
<img src="./images/JavaPrimitiveTypes.png" alt="alt text" width="900"/>

# Описание структуры проекта Intelije
<img src="./images/ideaFolder.png" alt="alt text" width="200"/>

Это кастомизация самого IDE в виде конфигураций, настроек, промежуточные состояния. Все это сохранятеся здесь. 
Этот каталог не нужен, его можно добавлять в .gitignore

.iml - так же файл, в котором информация, которая нужна только для меня, можно не обавлять в гит.

[Рекомендации по организации файлов в проекте Maven](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)

<img src="./images/mavenLayout.png" alt="alt text" width="900"/>

super - разрешен для записи, но не предоставляет инфу
extends - разрешен для предоставления инфы, но запрещен для записи
Пример - получаем список для записи и записываем в него другйо список.
```Java
public static <T> void copy (List<? super T> dest, List<? extends T> src){} 
```

## Generics
__Основа__
Обобщения позволяют уйти от жесткого определения используемых типов.
T - заглушка для типа. называется Универсальным параметром, вместо него можно подставить любой тип.
При создании объекта указывается какйо тип будет исопльзоваться вместо T.
```Java
class Account<T> {
    private T id;
    private int sum;

    public Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}

public class Generics {
    public static void main(String[] args) {
        Account tomAcc = new Account<Integer>(1, 100000);
        System.out.println(tomAcc.getId());
        System.out.println(tomAcc.getSum());

        Account mariAcc = new Account<String>("second", 10000);
        System.out.println(mariAcc.getId());
        System.out.println(mariAcc.getSum());
    }
}
```

__Обобщенные интерфейсы__
```Java
Можно сразу указывать тип, которым будет заменяться T, либо делать класс <T>.
interface PersonalAccount<T> {
    T getId();

    T getSum();

    void setSum(T newSum);
}

class MyPersonalAccount implements PersonalAccount<Integer> {

    int id;
    int sum;

    public MyPersonalAccount(int id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    @Override
    public Integer getId() {
        return id;
    }

    @Override
    public Integer getSum() {
        return sum;
    }

    @Override
    public void setSum(Integer newSum) {
        sum = newSum;
    }
}

public class Example2 {
    public static void main(String[] args) {
        MyPersonalAccount myPersonalAccount = new MyPersonalAccount(1, 123);
        System.out.println(myPersonalAccount.getId());
        myPersonalAccount.setSum(123);
        System.out.println(myPersonalAccount.getSum());
    }
}
```

__Обобщенные методы__
```Java
class Printer {
    public static <T> void print(T[] items) {
        for (T item : items) System.out.println(item);
    }
}

public class Example3 {
    public static void main(String[] args) {
        Printer.print(
                new String[]{
                        "123123",
                        "1425354",
                        "lkdfjqwef",
                        "ajd;flaksjdf"
                }
        );
    }
}
```

__Обобщенные конструкторы__
```Java
class Account{
     
    private String id;
    private int sum;
     
    <T>Account(T id, int sum){
        this.id = id.toString();
        this.sum = sum;
    }
     
    public String getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}
```

__Ограничение обобщений__
Для установки ограничения тавится слово __extends__
В данном случае в классе __Transaction__ можно заменить __T__ на класс __Account__, либо на любого его наследника.
```Java
class Account{}
class Transaction<T extends Account>{}
```
```Java
class BaseAccount {
    private int id;
    private int sum;

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }

    public int getId() {
        return id;
    }

    public BaseAccount(int id, int sum) {
        this.id = id;
        this.sum = sum;
    }
}

class ClassicAccount extends BaseAccount {

    public ClassicAccount(int id, int sum) {
        super(id, sum);
    }
}

class Transaction<T extends BaseAccount> {
    private T from;
    private T to;
    private int sum;

    public Transaction(T from, T to, int sum) {
        this.from = from;
        this.to = to;
        this.sum = sum;
    }

    public void execute() {
        int newSum = from.getSum() - sum;
        from.setSum(newSum);

        newSum = to.getSum() + sum;
        to.setSum(newSum);
    }
}

public class Example4 {
    public static void main(String[] args) {
        ClassicAccount bob = new ClassicAccount(1, 10000);
        ClassicAccount mari = new ClassicAccount(2, 0);
        System.out.println(bob.getSum());
        System.out.println(mari.getSum());

        Transaction sendMoney = new Transaction<>(bob, mari, 10000);
        sendMoney.execute();
        System.out.println(bob.getSum());
        System.out.println(mari.getSum());
    }
}
```

## Многопоточность Java
__Процесс и поток (Thread)_ - Это совокупность кода и данных, разделяющих общее виртуальное адрессное пространство.

При помощи процессов выполнение разных программ изолированно друг от друга: каждое приложение использует свою область памяти, не мешая другим программам.

<img src="./images/thread.png" alt="alt text" width="900"/>

Под процесс выделяется стековая память при запуске, по мере работы процесса он потребляет память из кучи.
Процесс не может влезть в память другого процесса их память изолирвоанна. 
За изолированность отвечает операционная система.
При запуске прцоесса запускается основной поток данного процесса Main thread. 
Когда мы входим в main - точка входа в программу - запускается основной поток. Процесс не может работать без основного потока.
В рамках одного процесса может быть запущено много потоков, которые как раз и помогают распаралеливать задачи.

Потоки - если у нас 4 ядра процессора и 4 потока, то они реально физически работуют параллельно, но если у нас 30 потоков, то 4 ядра не могут распараллелить их, поэтому появляется термин Псевдопараллельность.
Операционная система (sheduler модуль) поочередно дает управление каждому потоку.

В большинстве случаев имеет место всевдопараллельность.

Как создать поток и запустить его.
1. Нужно переопределить класс Thread
2. Затем где это нужно запустить его thread.start();
Другой вариант:
1. Использовать интерфейс Runnable
2. и через функцию run() запустить его.

С помощью Sleep можно заморозить процесс на некоторое время
<img src="./images/sleep.png" alt="alt text" width="900"/>
С помощью join можно подождать завершение другого потока.
<img src="./images/join.png" alt="alt text" width="900"/>

__Монитор__ - для целей синхронизации между потоками Java использует некий механизм, который назвается монитор.
С каждым объектом ассоциирован некоторый монитор, а потоки могут его заблогировать "lock" или разблокировать "unlock"
<img src="./images/monitor.png" alt="alt text" width="900"/>
<img src="./images/mark_words.png" alt="alt text" width="500"/>

__Жизненный цикл потоков__
<img src="./images/thread_lifecycle.png" alt="alt text" width="900"/>